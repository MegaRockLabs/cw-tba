import type { AminoMsg, Secp256k1HdWallet } from '@cosmjs/amino';
import type { setupWasmExtension, SigningCosmWasmClient } from '@cosmjs/cosmwasm-stargate';
import { DirectSecp256k1HdWallet, Registry } from '@cosmjs/proto-signing';
import type { QueryClient, setupBankExtension } from '@cosmjs/stargate';

export interface MsgSignData extends AminoMsg {
	readonly type: 'sign/MsgSignData';
	readonly value: { signer: string; data: string };
}

export type TokenAccount<T = string> = {
	account_data: T;
	token_info: TokenInfo;
	create_for?: string | null;
};

export type CreateAccount<T = string> = { chain_id: string; code_id: number; msg: TokenAccount<T> };

export type CreateAccountMsg<T = CredentialData> = { create_account: CreateAccount<T> };

/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.9.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

export type Uint128 = string;

export interface InstantiateMsg {
	params: RegistryParamsForNullable_Empty;
}

export interface RegistryParamsForNullable_Empty {
	allowed_code_ids: number[];
	creation_fees: Coin[];
	extension?: Empty | null;
	managers: string[];
}

export interface Coin {
	amount: Uint128;
	denom: string;
	[k: string]: unknown;
}

export interface Empty {
	[k: string]: unknown;
}

export type RegistryMsg =
	| {
		update_account_ownership: {
			new_account_data?: CredentialData | null;
			token_info: TokenInfo;
			update_for?: string | null;
		};
	}
	| {
		update_account_data: {
			signed?: SignedDataMsg | null;
			token_info: TokenInfo;
			update_op: UpdateOperationForCredentialData;
		};
	}
	| { reset_account: CreateAccountMsgForTokenAccountForExecuteAccountMsg }
	| { migrate_account: { msg: MigrateAccountMsg; new_code_id: number; token_info: TokenInfo } }
	| { create_account: CreateAccountMsgForTokenAccountForExecuteAccountMsg };

export interface Cw721ReceiveMsg {
	msg: Binary;
	sender: string;
	token_id: string;
}

export type CredentialAddress = { evm: string } | { bech32: string };

export type CredentialName =
	| 'native'
	| 'cosmos_arbitrary'
	| 'eth_typed_data'
	| 'passkey'
	| 'ed25519';

export interface PasskeyInfo {
	authenticator_data: Binary;
	crossOrigin: boolean;
	origin: string;
	pubkey: Binary;
	user_handle?: string | null;
}

export interface EthTypedInfo {
	addr_hash?: string | null;
	pre_hash: number[];
	salt_used: boolean;
}

export type InfoExtension = { passkey: PasskeyInfo } | { eth_typed_data: EthTypedInfo } | {
	custom: Binary;
};

export interface CredentialInfo {
	address?: CredentialAddress;
	extension?: InfoExtension;
	hrp?: string;
	name: CredentialName;
}

export interface VerifiedData {
	addresses: CredentialAddress[];
	credentials: [string, CredentialInfo][];
	has_extensions: boolean;
	has_natives: boolean;
	nonce: number;
	override_primary: boolean;
	primary_id: string;
}

export type UpdateOperationForVerifiedData = { add: VerifiedData } | { remove: string[] };

/* export type ExecuteMsg =
	| { update_ownership: { new_account_data?: VerifiedData | null; new_owner: string } }
	| { update_account_data: UpdateOperationForVerifiedData }
	| { receive_nft: Cw721ReceiveMsg }
	| { freeze: {} }
	| { purge: {} }
	| { execute: { msgs: CosmosMsgForEmpty[] } }
	| { execute_signed: { msgs: ExecuteAccountMsg[]; signed: SignedDataMsg } }
	| { execute_native: { msgs: ExecuteAccountMsg[] } };
 */

export type ExecuteMsg =
	| { update_ownership: { new_account_data?: VerifiedData; new_owner: string } }
	| { update_account_data: UpdateOperationForVerifiedData }
	| { receive_nft: Cw721ReceiveMsg }
	| { freeze: {} }
	| { purge: {} }
	| { execute: { msgs: CosmosMsgForEmpty[] } }
	| { execute_signed: { msg: ExecuteAccountMsg; signed: Credential } };

export interface Eip712Domain {
	chainId?: Uint64;
	name?: string;
	salt?: Uint8Array;
	verifyingContract?: string;
	version?: string;
}
export interface Eip712Message {
	[k: string]: unknown;
}

export interface Eip712DomainType {
	name: string;
	type: string;
}

export interface EthTypedData {
	domain: Eip712Domain;
	message: Eip712Message;
	message_property?: string;
	primaryType: string;
	signature: Binary;
	signer: string;
	types: { [k: string]: Eip712DomainType[] };
}

export type Credential =
	| { native: Caller }
	| { eth_typed_data: EthTypedData }
	| { cosmos_arbitrary: CosmosArbitrary }
	| { passkey: PasskeyCredential }
	| { ed25519: Ed25519 };

export type Caller = string;

export type Binary = string;

export type PayloadExtension = { passkey: PasskeyPayload } | { custom: Binary };

export type UpdateOperationForCredentialData = { add: CredentialData } | { remove: string[] };

export type ExecuteAccountMsg =
	| { execute: { msgs: CosmosMsgForEmpty[] } }
	| { mint_token: { minter: string; msg: Binary } }
	| { send_token: { collection: string; contract: string; msg: Binary; token_id: string } }
	| { transfer_token: { collection: string; recipient: string; token_id: string } }
	| { forget_tokens: { collection: string; token_ids: string[] } }
	| { fee_grant: { allowance?: BasicAllowance | null; grantee: string } }
	| { freeze: {} }
	| { unfreeze: {} }
	| {
		update_known_tokens: { collection: string; limit?: number | null; start_after?: string | null };
	};

export type CosmosMsgForEmpty =
	| { bank: BankMsg }
	| { custom: Empty }
	| { staking: StakingMsg }
	| { distribution: DistributionMsg }
	| { stargate: { type_url: string; value: Binary } }
	| { ibc: IbcMsg }
	| { wasm: WasmMsg }
	| { gov: GovMsg };

export type BankMsg = { send: { amount: Coin[]; to_address: string } } | {
	burn: { amount: Coin[] };
};

export type StakingMsg = { delegate: { amount: Coin; validator: string } } | {
	undelegate: { amount: Coin; validator: string };
} | { redelegate: { amount: Coin; dst_validator: string; src_validator: string } };

export type DistributionMsg = { set_withdraw_address: { address: string } } | {
	withdraw_delegator_reward: { validator: string };
};

export type IbcMsg =
	| {
		transfer: {
			amount: Coin;
			channel_id: string;
			timeout: IbcTimeout;
			to_address: string;
			[k: string]: unknown;
		};
	}
	| { send_packet: { channel_id: string; data: Binary; timeout: IbcTimeout; [k: string]: unknown } }
	| { close_channel: { channel_id: string; [k: string]: unknown } };
export type Timestamp = Uint64;
export type Uint64 = string;
export type WasmMsg =
	| { execute: { contract_addr: string; funds: Coin[]; msg: Binary; [k: string]: unknown } }
	| {
		instantiate: {
			admin?: string | null;
			code_id: number;
			funds: Coin[];
			label: string;
			msg: Binary;
			[k: string]: unknown;
		};
	}
	| { migrate: { contract_addr: string; msg: Binary; new_code_id: number; [k: string]: unknown } }
	| { update_admin: { admin: string; contract_addr: string; [k: string]: unknown } }
	| { clear_admin: { contract_addr: string; [k: string]: unknown } };
export type GovMsg = { vote: { proposal_id: number; vote: VoteOption; [k: string]: unknown } };
export type VoteOption = 'yes' | 'no' | 'abstain' | 'no_with_veto';
export interface CredentialData {
	credentials: Credential[];
	override_primary?: boolean | null;
	pre_validate?: boolean | null;
	primary_index?: number | null;
	use_native?: boolean | null;
}
export interface EthPersonalSign {
	message: Binary;
	signature: Binary;
	signer: string;
}
export interface CosmosArbitrary {
	address: string;
	message: Binary;
	pubkey: Binary;
	signature: Binary;
}
export interface PasskeyCredential {
	authenticator_data: Binary;
	client_data: ClientData;
	id: string;
	pubkey?: Binary | null;
	signature: Binary;
	user_handle?: string | null;
}
export interface ClientData {
	challenge: string;
	crossOrigin: boolean;
	origin: string;
	other_keys_can_be_added_here?: string | null;
	type: string;
}
export interface Ed25519 {
	message: Binary;
	pubkey: Binary;
	signature: Binary;
}
export interface TokenInfo {
	collection: string;
	id: string;
}
export interface SignedDataMsg {
	data: Binary;
	payload?: AuthPayload;
	signature: Binary;
}
export interface AuthPayload {
	credential_id?: string;
	extension?: PayloadExtension;
	hrp?: string | null;
}
export interface PasskeyPayload {
	origin?: string | null;
	other_keys?: ClientDataOtherKeys;
	[k: string]: unknown;
}
export interface ClientDataOtherKeys {
	other_keys_can_be_added_here?: string;
	[k: string]: unknown;
}
export interface CreateAccountMsgForTokenAccountForExecuteAccountMsg {
	account_data: TokenAccountForExecuteAccountMsg;
	chain_id: string;
	code_id: number;
}
export interface TokenAccountForExecuteAccountMsg {
	credential_data: CredentialData;
	actions?: ExecuteAccountMsg[] | null;
	create_for?: string | null;
	token_info: TokenInfo;
}
export interface IbcTimeout {
	block?: IbcTimeoutBlock | null;
	timestamp?: Timestamp | null;
	[k: string]: unknown;
}
export interface IbcTimeoutBlock {
	height: number;
	revision: number;
	[k: string]: unknown;
}
export interface BasicAllowance {
	expiration?: Timestamp | null;
	spend_limit: Coin[];
}
export interface MigrateAccountMsg {
	params?: Binary | null;
}
export type QueryMsg = { registry_params: {} } | { account_info: TokenInfo } | {
	accounts: {
		limit?: number | null;
		query?: AccountsQueryMsg | null;
		skip?: number | null;
		start_after?: string | null;
	};
};
export type AccountsQueryMsg = { collection: string } | { collections: {} };
export interface MigrateMsg {}
export interface AccountResponseForTokenInfo {
	address: string;
	info: TokenInfo;
}
export interface AccountsResponseForNullable_TokenInfo {
	accounts: AccountResponseForNullable_TokenInfo[];
	total: number;
}
export interface AccountResponseForNullable_TokenInfo {
	address: string;
	info?: TokenInfo | null;
}

export interface ContractDeployInfo {
	code_id: number;
	address: string;
}

export interface ChainConfig {
	denom: string;
	prefix: string;
	chain_id: string;
	rpc_endpoint: string;
	grpc_endpoint: string;
	gas_price: number;
	gas_adjustment: number;
	derivation_path: string;
}

export interface Account {
	name: string;
	address: string;
	mnemonic: string;
}

export interface SigningAccount {
	account: Account;
	key: any; // Will be populated with actual signing key
}

export interface TestSetupData {
	registry: string;
	collection: string;
	token_id: string;
	token_account: string;
	signer_address: string;
	public_key: string;
}

export interface MsgDataToSign {
	chain_id: string;
	contract_address: string;
	messages: string[];
	nonce: number | string;
}

export interface Contract {
	code_id: number;
	name: ContractName;
	address?: string;
	migrate?: boolean;
}

export interface ContractInfo {
	contracts: Contract[];
	deployment_timestamp?: string;
	chain_id?: string;
	deployer_address?: string;
}

export type ContractConfig = Record<ContractName, ContractDeployInfo>;

export type ChainQueryClient =
	& QueryClient
	& ReturnType<typeof setupWasmExtension>
	& ReturnType<typeof setupBankExtension>;

export type ChainData = {
	wallet: Secp256k1HdWallet;
	address: string;
	client: SigningCosmWasmClient;
	queryClient: ChainQueryClient;
	contracts: ContractConfig;
	config: ChainConfig;
	accounts: Account[];
};

export type OwnerOfResponse = { owner: string; approvals?: any[] };

export interface FullInfoResponse {
	balances: Coin[];
	credentials: StoredCredentials;
	ownership: OwnershipForAddr;
	registry: string;
	status: Status;
	token_info: TokenInfo;
	tokens: TokenInfo[];
}

export interface StoredCredentials {
	account_number: number;
	has_natives: boolean;
	primary_id: string;
	records: [string, CredentialInfo][];
}

export interface OwnershipForAddr {
	owner?: string;
	pending_expiry?: Expiration;
	pending_owner?: string;
}

export type Expiration = { at_height: number } | { at_time: Timestamp } | { never: {} };

export interface Status {
	frozen: boolean;
}

export const CREATION_FB_FEE = '100000000';

// Contract management types
export type ContractName =
	| 'cw721_base'
	| 'cw82_tba_base'
	| 'cw82_tba_credentials'
	| 'cw83_tba_registry';
